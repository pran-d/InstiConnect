"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = getCollectionEntries;

function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread(); }

function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function _iterableToArray(iter) { if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter); }

function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) return _arrayLikeToArray(arr); }

function _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it["return"] != null) it["return"](); } finally { if (didErr) throw err; } } }; }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

function getLength(type, collection) {
  if (type === 'Object') {
    // eslint-disable-next-line @typescript-eslint/ban-types
    return Object.keys(collection).length;
  } else if (type === 'Array') {
    return collection.length;
  }

  return Infinity;
}

function isIterableMap(collection) {
  return typeof collection.set === 'function';
}

function getEntries(type, collection, sortObjectKeys) {
  var from = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;
  var to = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : Infinity;
  var res;

  if (type === 'Object') {
    var keys = Object.getOwnPropertyNames(collection);

    if (sortObjectKeys) {
      keys.sort(sortObjectKeys === true ? undefined : sortObjectKeys);
    }

    keys = keys.slice(from, to + 1);
    res = {
      entries: keys.map(function (key) {
        return {
          key: key,
          value: collection[key]
        };
      })
    };
  } else if (type === 'Array') {
    res = {
      entries: collection.slice(from, to + 1).map(function (val, idx) {
        return {
          key: idx + from,
          value: val
        };
      })
    };
  } else {
    var idx = 0;
    var entries = [];
    var done = true;
    var isMap = isIterableMap(collection);

    var _iterator = _createForOfIteratorHelper(collection),
        _step;

    try {
      for (_iterator.s(); !(_step = _iterator.n()).done;) {
        var item = _step.value;

        if (idx > to) {
          done = false;
          break;
        }

        if (from <= idx) {
          if (isMap && Array.isArray(item)) {
            if (typeof item[0] === 'string' || typeof item[0] === 'number') {
              entries.push({
                key: item[0],
                value: item[1]
              });
            } else {
              entries.push({
                key: "[entry ".concat(idx, "]"),
                value: {
                  '[key]': item[0],
                  '[value]': item[1]
                }
              });
            }
          } else {
            entries.push({
              key: idx,
              value: item
            });
          }
        }

        idx++;
      }
    } catch (err) {
      _iterator.e(err);
    } finally {
      _iterator.f();
    }

    res = {
      hasMore: !done,
      entries: entries
    };
  }

  return res;
}

function getRanges(from, to, limit) {
  var ranges = [];

  while (to - from > limit * limit) {
    limit = limit * limit;
  }

  for (var i = from; i <= to; i += limit) {
    ranges.push({
      from: i,
      to: Math.min(to, i + limit - 1)
    });
  }

  return ranges;
}

function getCollectionEntries(type, collection, sortObjectKeys, limit) {
  var from = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 0;
  var to = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : Infinity;
  var getEntriesBound = getEntries.bind(null, type, collection, sortObjectKeys);

  if (!limit) {
    return getEntriesBound().entries;
  }

  var isSubset = to < Infinity;
  var length = Math.min(to - from, getLength(type, collection));

  if (type !== 'Iterable') {
    if (length <= limit || limit < 7) {
      return getEntriesBound(from, to).entries;
    }
  } else {
    if (length <= limit && !isSubset) {
      return getEntriesBound(from, to).entries;
    }
  }

  var limitedEntries;

  if (type === 'Iterable') {
    var _getEntriesBound = getEntriesBound(from, from + limit - 1),
        hasMore = _getEntriesBound.hasMore,
        entries = _getEntriesBound.entries;

    limitedEntries = hasMore ? [].concat(_toConsumableArray(entries), _toConsumableArray(getRanges(from + limit, from + 2 * limit - 1, limit))) : entries;
  } else {
    limitedEntries = isSubset ? getRanges(from, to, limit) : [].concat(_toConsumableArray(getEntriesBound(0, limit - 5).entries), _toConsumableArray(getRanges(limit - 4, length - 5, limit)), _toConsumableArray(getEntriesBound(length - 4, length - 1).entries));
  }

  return limitedEntries;
}
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uL3NyYy9nZXRDb2xsZWN0aW9uRW50cmllcy50cyJdLCJuYW1lcyI6WyJnZXRMZW5ndGgiLCJ0eXBlIiwiY29sbGVjdGlvbiIsIk9iamVjdCIsImtleXMiLCJsZW5ndGgiLCJJbmZpbml0eSIsImlzSXRlcmFibGVNYXAiLCJzZXQiLCJnZXRFbnRyaWVzIiwic29ydE9iamVjdEtleXMiLCJmcm9tIiwidG8iLCJyZXMiLCJnZXRPd25Qcm9wZXJ0eU5hbWVzIiwic29ydCIsInVuZGVmaW5lZCIsInNsaWNlIiwiZW50cmllcyIsIm1hcCIsImtleSIsInZhbHVlIiwidmFsIiwiaWR4IiwiZG9uZSIsImlzTWFwIiwiaXRlbSIsIkFycmF5IiwiaXNBcnJheSIsInB1c2giLCJoYXNNb3JlIiwiZ2V0UmFuZ2VzIiwibGltaXQiLCJyYW5nZXMiLCJpIiwiTWF0aCIsIm1pbiIsImdldENvbGxlY3Rpb25FbnRyaWVzIiwiZ2V0RW50cmllc0JvdW5kIiwiYmluZCIsImlzU3Vic2V0IiwibGltaXRlZEVudHJpZXMiXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFBLFNBQVNBLFNBQVQsQ0FBbUJDLElBQW5CLEVBQWlDQyxVQUFqQyxFQUFrRDtBQUNoRCxNQUFJRCxJQUFJLEtBQUssUUFBYixFQUF1QjtBQUNyQjtBQUNBLFdBQU9FLE1BQU0sQ0FBQ0MsSUFBUCxDQUFZRixVQUFaLEVBQThCRyxNQUFyQztBQUNELEdBSEQsTUFHTyxJQUFJSixJQUFJLEtBQUssT0FBYixFQUFzQjtBQUMzQixXQUFRQyxVQUFELENBQTBCRyxNQUFqQztBQUNEOztBQUVELFNBQU9DLFFBQVA7QUFDRDs7QUFFRCxTQUFTQyxhQUFULENBQXVCTCxVQUF2QixFQUF3QztBQUN0QyxTQUFPLE9BQVFBLFVBQUQsQ0FBOEJNLEdBQXJDLEtBQTZDLFVBQXBEO0FBQ0Q7O0FBRUQsU0FBU0MsVUFBVCxDQUNFUixJQURGLEVBRUVDLFVBRkYsRUFHRVEsY0FIRixFQU0wRTtBQUFBLE1BRnhF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LENBQVQsRUFBWTNCLE1BQU0sR0FBRyxDQUFyQixFQUF3QjJCLEtBQXhCLENBSk8sc0JBS2hCTSxlQUFlLENBQUNqQyxNQUFNLEdBQUcsQ0FBVixFQUFhQSxNQUFNLEdBQUcsQ0FBdEIsQ0FBZixDQUF3Q2EsT0FMeEIsRUFBekI7QUFPRDs7QUFFRCxTQUFPdUIsY0FBUDtBQUNEIiwic291cmNlc0NvbnRlbnQiOlsiZnVuY3Rpb24gZ2V0TGVuZ3RoKHR5cGU6IHN0cmluZywgY29sbGVjdGlvbjogYW55KSB7XG4gIGlmICh0eXBlID09PSAnT2JqZWN0Jykge1xuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvYmFuLXR5cGVzXG4gICAgcmV0dXJuIE9iamVjdC5rZXlzKGNvbGxlY3Rpb24gYXMge30pLmxlbmd0aDtcbiAgfSBlbHNlIGlmICh0eXBlID09PSAnQXJyYXknKSB7XG4gICAgcmV0dXJuIChjb2xsZWN0aW9uIGFzIHVua25vd25bXSkubGVuZ3RoO1xuICB9XG5cbiAgcmV0dXJuIEluZmluaXR5O1xufVxuXG5mdW5jdGlvbiBpc0l0ZXJhYmxlTWFwKGNvbGxlY3Rpb246IGFueSkge1xuICByZXR1cm4gdHlwZW9mIChjb2xsZWN0aW9uIGFzIE1hcDxhbnksIGFueT4pLnNldCA9PT0gJ2Z1bmN0aW9uJztcbn1cblxuZnVuY3Rpb24gZ2V0RW50cmllcyhcbiAgdHlwZTogc3RyaW5nLFxuICBjb2xsZWN0aW9uOiBhbnksXG4gIHNvcnRPYmplY3RLZXlzPzogKChhOiBhbnksIGI6IGFueSkgPT4gbnVtYmVyKSB8IGJvb2xlYW4gfCB1bmRlZmluZWQsXG4gIGZyb20gPSAwLFxuICB0byA9IEluZmluaXR5XG4pOiB7IGVudHJpZXM6IHsga2V5OiBzdHJpbmcgfCBudW1iZXI7IHZhbHVlOiBhbnkgfVtdOyBoYXNNb3JlPzogYm9vbGVhbiB9IHtcbiAgbGV0IHJlcztcblxuICBpZiAodHlwZSA9PT0gJ09iamVjdCcpIHtcbiAgICBsZXQga2V5cyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKGNvbGxlY3Rpb24pO1xuXG4gICAgaWYgKHNvcnRPYmplY3RLZXlzKSB7XG4gICAgICBrZXlzLnNvcnQoc29ydE9iamVjdEtleXMgPT09IHRydWUgPyB1bmRlZmluZWQgOiBzb3J0T2JqZWN0S2V5cyk7XG4gICAgfVxuXG4gICAga2V5cyA9IGtleXMuc2xpY2UoZnJvbSwgdG8gKyAxKTtcblxuICAgIHJlcyA9IHtcbiAgICAgIGVudHJpZXM6IGtleXMubWFwKChrZXkpID0+ICh7IGtleSwgdmFsdWU6IGNvbGxlY3Rpb25ba2V5XSB9KSksXG4gICAgfTtcbiAgfSBlbHNlIGlmICh0eXBlID09PSAnQXJyYXknKSB7XG4gICAgcmVzID0ge1xuICAgICAgZW50cmllczogY29sbGVjdGlvblxuICAgICAgICAuc2xpY2UoZnJvbSwgdG8gKyAxKVxuICAgICAgICAubWFwKCh2YWw6IHVua25vd24sIGlkeDogbnVtYmVyKSA9PiAoeyBrZXk6IGlkeCArIGZyb20sIHZhbHVlOiB2YWwgfSkpLFxuICAgIH07XG4gIH0gZWxzZSB7XG4gICAgbGV0IGlkeCA9IDA7XG4gICAgY29uc3QgZW50cmllcyA9IFtdO1xuICAgIGxldCBkb25lID0gdHJ1ZTtcblxuICAgIGNvbnN0IGlzTWFwID0gaXNJdGVyYWJsZU1hcChjb2xsZWN0aW9uKTtcblxuICAgIGZvciAoY29uc3QgaXRlbSBvZiBjb2xsZWN0aW9uKSB7XG4gICAgICBpZiAoaWR4ID4gdG8pIHtcbiAgICAgICAgZG9uZSA9IGZhbHNlO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIGlmIChmcm9tIDw9IGlkeCkge1xuICAgICAgICBpZiAoaXNNYXAgJiYgQXJyYXkuaXNBcnJheShpdGVtKSkge1xuICAgICAgICAgIGlmICh0eXBlb2YgaXRlbVswXSA9PT0gJ3N0cmluZycgfHwgdHlwZW9mIGl0ZW1bMF0gPT09ICdudW1iZXInKSB7XG4gICAgICAgICAgICBlbnRyaWVzLnB1c2goeyBrZXk6IGl0ZW1bMF0sIHZhbHVlOiBpdGVtWzFdIH0pO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBlbnRyaWVzLnB1c2goe1xuICAgICAgICAgICAgICBrZXk6IGBbZW50cnkgJHtpZHh9XWAsXG4gICAgICAgICAgICAgIHZhbHVlOiB7XG4gICAgICAgICAgICAgICAgJ1trZXldJzogaXRlbVswXSxcbiAgICAgICAgICAgICAgICAnW3ZhbHVlXSc6IGl0ZW1bMV0sXG4gICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZW50cmllcy5wdXNoKHsga2V5OiBpZHgsIHZhbHVlOiBpdGVtIH0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZHgrKztcbiAgICB9XG5cbiAgICByZXMgPSB7XG4gICAgICBoYXNNb3JlOiAhZG9uZSxcbiAgICAgIGVudHJpZXMsXG4gICAgfTtcbiAgfVxuXG4gIHJldHVybiByZXM7XG59XG5cbmZ1bmN0aW9uIGdldFJhbmdlcyhmcm9tOiBudW1iZXIsIHRvOiBudW1iZXIsIGxpbWl0OiBudW1iZXIpIHtcbiAgY29uc3QgcmFuZ2VzID0gW107XG4gIHdoaWxlICh0byAtIGZyb20gPiBsaW1pdCAqIGxpbWl0KSB7XG4gICAgbGltaXQgPSBsaW1pdCAqIGxpbWl0O1xuICB9XG4gIGZvciAobGV0IGkgPSBmcm9tOyBpIDw9IHRvOyBpICs9IGxpbWl0KSB7XG4gICAgcmFuZ2VzLnB1c2goeyBmcm9tOiBpLCB0bzogTWF0aC5taW4odG8sIGkgKyBsaW1pdCAtIDEpIH0pO1xuICB9XG5cbiAgcmV0dXJuIHJhbmdlcztcbn1cblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gZ2V0Q29sbGVjdGlvbkVudHJpZXMoXG4gIHR5cGU6IHN0cmluZyxcbiAgY29sbGVjdGlvbjogYW55LFxuICBzb3J0T2JqZWN0S2V5czogKChhOiBhbnksIGI6IGFueSkgPT4gbnVtYmVyKSB8IGJvb2xlYW4gfCB1bmRlZmluZWQsXG4gIGxpbWl0OiBudW1iZXIsXG4gIGZyb20gPSAwLFxuICB0byA9IEluZmluaXR5XG4pIHtcbiAgY29uc3QgZ2V0RW50cmllc0JvdW5kID0gZ2V0RW50cmllcy5iaW5kKFxuICAgIG51bGwsXG4gICAgdHlwZSxcbiAgICBjb2xsZWN0aW9uLFxuICAgIHNvcnRPYmplY3RLZXlzXG4gICk7XG5cbiAgaWYgKCFsaW1pdCkge1xuICAgIHJldHVybiBnZXRFbnRyaWVzQm91bmQoKS5lbnRyaWVzO1xuICB9XG5cbiAgY29uc3QgaXNTdWJzZXQgPSB0byA8IEluZmluaXR5O1xuICBjb25zdCBsZW5ndGggPSBNYXRoLm1pbih0byAtIGZyb20sIGdldExlbmd0aCh0eXBlLCBjb2xsZWN0aW9uKSk7XG5cbiAgaWYgKHR5cGUgIT09ICdJdGVyYWJsZScpIHtcbiAgICBpZiAobGVuZ3RoIDw9IGxpbWl0IHx8IGxpbWl0IDwgNykge1xuICAgICAgcmV0dXJuIGdldEVudHJpZXNCb3VuZChmcm9tLCB0bykuZW50cmllcztcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgaWYgKGxlbmd0aCA8PSBsaW1pdCAmJiAhaXNTdWJzZXQpIHtcbiAgICAgIHJldHVybiBnZXRFbnRyaWVzQm91bmQoZnJvbSwgdG8pLmVudHJpZXM7XG4gICAgfVxuICB9XG5cbiAgbGV0IGxpbWl0ZWRFbnRyaWVzO1xuICBpZiAodHlwZSA9PT0gJ0l0ZXJhYmxlJykge1xuICAgIGNvbnN0IHsgaGFzTW9yZSwgZW50cmllcyB9ID0gZ2V0RW50cmllc0JvdW5kKGZyb20sIGZyb20gKyBsaW1pdCAtIDEpO1xuXG4gICAgbGltaXRlZEVudHJpZXMgPSBoYXNNb3JlXG4gICAgICA/IFsuLi5lbnRyaWVzLCAuLi5nZXRSYW5nZXMoZnJvbSArIGxpbWl0LCBmcm9tICsgMiAqIGxpbWl0IC0gMSwgbGltaXQpXVxuICAgICAgOiBlbnRyaWVzO1xuICB9IGVsc2Uge1xuICAgIGxpbWl0ZWRFbnRyaWVzID0gaXNTdWJzZXRcbiAgICAgID8gZ2V0UmFuZ2VzKGZyb20sIHRvLCBsaW1pdClcbiAgICAgIDogW1xuICAgICAgICAgIC4uLmdldEVudHJpZXNCb3VuZCgwLCBsaW1pdCAtIDUpLmVudHJpZXMsXG4gICAgICAgICAgLi4uZ2V0UmFuZ2VzKGxpbWl0IC0gNCwgbGVuZ3RoIC0gNSwgbGltaXQpLFxuICAgICAgICAgIC4uLmdldEVudHJpZXNCb3VuZChsZW5ndGggLSA0LCBsZW5ndGggLSAxKS5lbnRyaWVzLFxuICAgICAgICBdO1xuICB9XG5cbiAgcmV0dXJuIGxpbWl0ZWRFbnRyaWVzO1xufVxuIl19